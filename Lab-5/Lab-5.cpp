#include <iostream>
#include <Windows.h>//библиотека для русского ввода/вывода
#include <string> //стринговая библиотека
#include <sstream>

int main()
{
    SetConsoleCP(1251);//русский ввод
    SetConsoleOutputCP(1251);//вывод
    int check = 0;
    int p;
    int h = 0;//если не занулить не работает
    int n;
    int o;
    char c;//для символа строки
    std::string s = "Результат: ";
    std::string m;//сама строка
    std::string z;//сама строка
    std::string l = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
    while (check < 1)
    {
        std::cout << "Введите шаг шифрования число от (-33 до 33) n= ";
        std::cin >> n;//если n огромно всё ломается фиксим
        if ((n < 0) | (n > -1))
        {
            std::cout << "Ввод шага выполнен" << std::endl;
            while (n < 0)
            {
                n = 33 - fabs(n);//добавил фикс для отрицательного шага, в исходном задании не заметил)
            }
            check = 1;
        }
        else
            std::cout << "Ввод шага невыполнен, пользователь допустил ошибку ввода" << std::endl;
    }
    n = n % 33;//если n огромно упрощает нам жизнь
    check = 0;
    std::cout << "Введите строку для шифрования русскими буквами " << std::endl;
    std::cin >> z;// столкнулся с проблемой гетлайн пропускает первое слово. для этого использовал конструкцию конкатенации строк з и м где м считывает до пробела а м после.
    std::getline(std::cin, m);
    m = z + m;

    std::string::iterator end_pos = std::remove(m.begin(), m.end(), ' ');
    m.erase(end_pos, m.end());//чистим пробелы из строки
    //std::cout << m << std::endl;//проверка чистки пробелов получается строка для шифровки не думаю что будет лишним показать что шифруется
    p = m.length();//для цикла, немного экономим память
    for (int i = 0; i < p; i++)
    {
        c = m[i];//берем итый символ
        h = l.find_first_of(c);//ищем символ в строке алфавита
        o = n + h;//добавляем шаг кодировки найденному номеру символа алфавита
        if (o >= 33)//если символ превысит алфавит то начинаем с абв снова
        {
            o -= 33;
        }
        m[i] = l[o];//присваиваем итому значению новый символ
        h = 0;
    }
    std::cout << "Вывод полученной строки:" << std::endl;
    std::cout << m << std::endl;
    return 0;
}

